import std::vector::Vector
import std::vec::Vec3f
import std::sort::{ nth_element_by, partition_by_closure }  // def nth_element_by(data: &T, size: u32, n: u32, cmp: <unknown>): T
import std::time::get_time_monotonic_ms
import std::logging::{ log }

import @bounds::Bounds
import @ray::Ray

struct BVH<T> {
    bounds: Bounds
    is_leaf: bool
    obj: T
    l: &BVH<T>
    r: &BVH<T>
}

def BVH::split_equal(objects: &Vector<T>, start: u32, end: u32, bounds: Bounds, axis: u32): u32 {
    let mid = (start + end) / 2
    nth_element_by<T>(objects.data + start, end - start, mid, |a,b| {
        let ka = (a.bounds().min + a.bounds().max)[axis]
        let kb = (b.bounds().min + b.bounds().max)[axis]
        return ka.compare(kb)
    })
    return mid
}

const NUM_BUCKETS: u32 = 12

struct Bucket {
    count: u32,
    bounds: Bounds
}

def BVH::split_SAH(objects: &Vector<T>, start: u32, end: u32, bounds: Bounds, axis: u32): u32 {
    let buckets: [Bucket; NUM_BUCKETS]

    for let i = start; i < end; i++ {
        let b = (NUM_BUCKETS as f32 * bounds.offset(objects[i].bounds().centroid())[axis]) as u32
        if (b == NUM_BUCKETS) b = NUM_BUCKETS - 1
        buckets[b].count += 1
        buckets[b].bounds = buckets[b].bounds.join(objects[i].bounds())
    }

    let cost: [f32; NUM_BUCKETS - 1]
    for let i = 0; i < NUM_BUCKETS - 1; ++i {
        let b0 = Bounds::empty()
        let b1 = Bounds::empty()
        let c0 = 0
        let c1 = 0
        for let j = 0; j <= i; ++j {
            b0 = b0.join(buckets[j].bounds)
            c0 += buckets[j].count;
        }
        for let j = i + 1; j < NUM_BUCKETS; ++j {
            b1 = b1.join(buckets[j].bounds)
            c1 += buckets[j].count;
        }
        cost[i] = 0.125 + (c0 as f32 * b0.area() + c1 as f32 * b1.area()) / bounds.area();
    }

    let min_bucket = 0;
    for let i = 1; i < NUM_BUCKETS - 1; ++i {
        if cost[i] < cost[min_bucket] {
            min_bucket = i;
        }
    }

    let mid = start + partition_by_closure<T>(objects.data + start, end - start, |a| {
        let off = bounds.offset(a.bounds().centroid())
        let bucket = (NUM_BUCKETS as f32 * off[axis]) as u32
        if (bucket == NUM_BUCKETS) bucket = NUM_BUCKETS - 1
        return bucket <= min_bucket
    })

    // TODO: this is bad, but currently no support for multiple objects in node
    if (mid == start or mid == end) 
        mid = BVH<T>::split_equal(objects, start, end, bounds, axis)

    return mid;
}


def BVH::create_rec(objects: &Vector<T>, start: u32, end: u32): &BVH<T> {
    if end - start == 1 {
        let object = objects[start]
        let bounds = object.bounds()
        let leaf: BVH<T>
        leaf.is_leaf = true
        leaf.obj = object
        leaf.bounds = bounds
        return @new leaf
    } else {
        let bounds = Bounds::empty()
        for let i = start; i < end; i += 1 {
            bounds += objects[i].bounds()
        }
        let box_sizes = bounds.max - bounds.min

        let dim = 0
        if box_sizes[dim] < box_sizes[1] then dim = 1
        if box_sizes[dim] < box_sizes[2] then dim = 2

        let mid = BVH<T>::split_SAH(objects, start, end, bounds, dim)

        let l = BVH<T>::create_rec(objects, start, mid)
        let r = BVH<T>::create_rec(objects, mid, end)

        let internal: BVH<T>
        internal.is_leaf = false
        internal.l = l
        internal.r = r
        internal.bounds = bounds

        return @new internal
    }
}

def BVH::create(objects: &Vector<T>): &BVH<T> {
    let start_time = get_time_monotonic_ms()
    let bvh = BVH<T>::create_rec(objects, 0, objects.size)
    let duration = get_time_monotonic_ms() - start_time
    log(Info, f"BVH created with {objects.size} objects in {duration/1000.0:.2f}s")
    return bvh
}

def BVH::hit(&this, ray: &Ray, hit_nodes: &Vector<&BVH<T>>) {
    match .is_leaf {
        true => {
            hit_nodes.push(this)
        }
        false => {
            hit_nodes.push(this);
            let t_l = 0.0
            let t_r = 0.0
            let hit_l = .l.bounds.hit(ray, &t_l, &t_r, 1.0 / ray.dir)
            let hit_r = .r.bounds.hit(ray, &t_l, &t_r, 1.0 / ray.dir)
            if not hit_l and not hit_r then return
            if not hit_l {
                .r.hit(ray, hit_nodes)
                return
            }
            if not hit_r {
                .l.hit(ray, hit_nodes)
                return
            }
            if t_l < t_r {
                .l.hit(ray, hit_nodes)
                .r.hit(ray, hit_nodes)
            } else {
                .r.hit(ray, hit_nodes)
                .l.hit(ray, hit_nodes)
            }
        }
    }
}