import std::image::{ Image, Color, draw }
import std::vec::{ Vec2i, Vec2f, Vec3f }
import std::fs
import std::matrix::Matrix4f
import std::sdl

import @zbuffer::{ ZBuffer}

let size_f: Vec2f
let image: &Image
let zbuffer: &ZBuffer
let camera_transform: Matrix4f
let light_dir: Vec3f

def project_and_draw(p0: Vec3f, p1: Vec3f, p2: Vec3f, color: Color) {

    // project to camera space
    let p0_c = camera_transform * p0
    let p1_c = camera_transform * p1
    let p2_c = camera_transform * p2

    // project to screen space
    let p0_s = Vec2f(p0_c.x / p0_c.z, p0_c.y / p0_c.z)
    let p1_s = Vec2f(p1_c.x / p1_c.z, p1_c.y / p1_c.z)
    let p2_s = Vec2f(p2_c.x / p2_c.z, p2_c.y / p2_c.z)

    // project to image space (and flip y axis)
    let p0_i = (Vec2f(p0_s.x, -p0_s.y) + 1.0) * 0.5 * size_f
    let p1_i = (Vec2f(p1_s.x, -p1_s.y) + 1.0) * 0.5 * size_f
    let p2_i = (Vec2f(p2_s.x, -p2_s.y) + 1.0) * 0.5 * size_f

    // TEMP: color based on normal
    let normal = (p1 - p0).cross(p2 - p0).normalized()
    let scale = normal.dot(-1.0 * light_dir).max(0.1)

    normal = normal * 128.0 + 128.0
    // normal = normal * scale

    let c = Color(normal.x as u8, normal.y as u8, normal.z as u8)
    // let c = Color(scale as u8, scale as u8, scale as u8)

    fill_triangle(
        p0_i.to_i32(),
        p1_i.to_i32(),
        p2_i.to_i32(),
        p0_c.z,
        p1_c.z,
        p2_c.z,
        c
    )
}


def draw_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    draw::line(image, p0.x, p0.y, p1.x, p1.y, color)
    draw::line(image, p1.x, p1.y, p2.x, p2.y, color)
    draw::line(image, p2.x, p2.y, p0.x, p0.y, color)
}


def fill_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    let min_x = p0.x.min(p1.x.min(p2.x)).max(0)
    let min_y = p0.y.min(p1.y.min(p2.y)).max(0)
    let max_x = p0.x.max(p1.x.max(p2.x)).min((image.width - 1) as i32)
    let max_y = p0.y.max(p1.y.max(p2.y)).min((image.height - 1) as i32)

    let denom = (p0.x - p2.x)*(p1.y - p2.y) - (p1.x - p2.x)*(p0.y - p2.y)

    for let x = min_x; x <= max_x; x += 1 {
        for let y = min_y; y <= max_y; y += 1 {
            let u  = (p1.y - p2.y)*(x - p2.x) + (p2.x - p1.x)*(y - p2.y)
            let v  = (p2.y - p0.y)*(x - p2.x) + (p0.x - p2.x)*(y - p2.y)
            let w = denom - u - v

            if u >= 0 and v >= 0 and w >= 0 {
                let z = (z0 * u as f32 + z1 * v as f32 + z2 * w as f32) / denom as f32
                if zbuffer.put_if_closer(x as u32, y as u32, z) {
                    image.set(x as u32, y as u32, color)
                }
            }
        }
    }
}

struct Triangle {
    p0, p1, p2 : Vec3f
}


struct Mesh {
    triangles: $[Triangle]
}


def Mesh::from_obj(filename: str, offset: Vec3f): Mesh {
    let file = fs::read_file(filename)
    defer file.free()

    let sv = file.sv()
    let vectors: $[Vec3f] = $[]
    defer vectors.free()

    let normals: $[Vec3f] = $[]
    defer normals.free()

    let textures: $[Vec2f] = $[]
    defer textures.free()

    let triangles: $[Triangle] = $[]
    for line in sv.lines() {
        match line.chop_word() {
            "v" => vectors.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()) + offset)
            "vn" => normals.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()))
            "vt" => textures.push(Vec2f(line.chop_f32(), line.chop_f32()))
            "f" => {
                let s0 = line.chop_by_delim(' ')
                let v0 = vectors[s0.chop_u32() - 1]
                s0.chop_left(1)
                let t0 = textures[s0.chop_u32() - 1]
                s0.chop_left(1)
                let n0 = normals[s0.chop_u32() - 1]

                let s1 = line.chop_by_delim(' ')
                let v1 = vectors[s1.chop_u32() - 1]
                s1.chop_left(1)
                let t1 = textures[s1.chop_u32() - 1]
                s1.chop_left(1)
                let n1 = normals[s1.chop_u32() - 1]

                let s2 = line.chop_by_delim(' ')
                let v2 = vectors[s2.chop_u32() - 1]
                s2.chop_left(1)
                let t2 = textures[s2.chop_u32() - 1]
                s2.chop_left(1)
                let n2 = normals[s2.chop_u32() - 1]

                triangles += Triangle(v0, v1, v2)  //  n0, n1, n2, t0, t1, t2
            }
            else => {}
        }
    }
    let mesh = Mesh(triangles)

    return mesh
}

def update_camera(origin: &Vec3f, direction: &Vec3f) {
    let up = Vec3f(0.0, 1.0, 0.0)
    *direction = direction.normalized()
    let z = *direction
    let x = up.cross(z).normalized()
    let y = z.cross(x).normalized()

    camera_transform = Matrix4f::make(
        x.x, x.y, x.z, -origin.dot(x),
        y.x, y.y, y.z, -origin.dot(y),
        z.x, z.y, z.z, -origin.dot(z),
        0.0, 0.0, 0.0, 1.0
    )
}

def rotate_vector(v: Vec3f, axis: Vec3f, angle: f32): Vec3f {
    let cos_theta = angle.cos()
    let sin_theta = angle.sin()

    // v_rot = v*cos(theta) + (axis x v)*sin(theta) + axis*(axis . v)*(1-cos(theta))
    let term1 = v * cos_theta
    let term2 = axis.cross(v) * sin_theta
    let dot_av = axis.dot(v)
    let term3 = axis * dot_av * (1.0 - cos_theta)

    return term1 + term2 + term3
}

def main() {
    let width = 720
    let height = 720
    size_f = Vec2f(width as f32, height as f32)
    image = Image::new(width, height)
    zbuffer = ZBuffer::new(width, height)

    light_dir = Vec3f(1.0, -1.0, 0.0).normalized()

    let camera_pos = Vec3f(-4.0, 0.0, 2.0)
    let camera_dir = Vec3f(1.0, 0.0, 1.0)
    let camera_up = Vec3f(0.0, 1.0, 0.0)
    update_camera(&camera_pos, &camera_dir)

    let color = Color(255, 0, 0)
    let mesh = Mesh::from_obj("assets/dragon.obj", Vec3f(0.0, -2.0, 5.0))

    // SDL code follows
    sdl::init(sdl::INIT_EVERYTHING)
    sdl::set_relative_mouse_mode(true)

    let window: &sdl::Window
    let renderer: &sdl::Renderer
    sdl::create_window_renderer(width as i32, height as i32, 0, &window, &renderer)
    let texture = renderer.create_texture(
        sdl::PIXELFORMAT_ABGR8888,
        sdl::TEXTUREACCESS_STREAMING,
        width as i32,
        height as i32,
    )

    let MOVE_SENSITIVITY: f32 = 10.0
    let KEYBOARD_LOOK_SENSITIVITY: f32 = 1.5
    let MOUSE_LOOK_SENSITIVITY: f32 = 0.2
    let dtime: f32 = 0.0

    let rotate_camera = |dx: i32, dy: i32, sensitivity: f32| {
        if dx == 0 and dy == 0 return
        let yaw_rad = dx as f32 * sensitivity * dtime
        let pitch_rad = dy as f32 * sensitivity * dtime

        camera_dir = rotate_vector(camera_dir, camera_up, yaw_rad)
        let right = camera_dir.cross(camera_up).normalized()
        let new_dir_after_pitch = rotate_vector(camera_dir, right, pitch_rad)

        if new_dir_after_pitch.dot(camera_up).abs() < 0.995 {
            camera_dir = new_dir_after_pitch
        }
        update_camera(&camera_pos, &camera_dir)
    }

    let key_callbacks: ${sdl::Key: @fn()} = ${
        W: || {
            camera_pos = camera_pos + camera_dir * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        S: || {
            camera_pos = camera_pos - camera_dir * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        A: || {
            let delta = camera_dir.cross(Vec3f(0.0, 1.0, 0.0)).normalized() * dtime * MOVE_SENSITIVITY
            camera_pos = camera_pos + delta
            update_camera(&camera_pos, &camera_dir)
        },
        D: || {
            let delta = camera_dir.cross(Vec3f(0.0, 1.0, 0.0)).normalized() * dtime * MOVE_SENSITIVITY
            camera_pos = camera_pos - delta
            update_camera(&camera_pos, &camera_dir)
        },
        Z: || {
            camera_pos = camera_pos + camera_up * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        X: || {
            camera_pos = camera_pos - camera_up * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },

        Up:    || => rotate_camera(0, 1, KEYBOARD_LOOK_SENSITIVITY),
        Down:  || => rotate_camera(0, -1, KEYBOARD_LOOK_SENSITIVITY),
        Left:  || => rotate_camera(-1, 0, KEYBOARD_LOOK_SENSITIVITY),
        Right: || => rotate_camera(1, 0, KEYBOARD_LOOK_SENSITIVITY),
    }

    let prev_ticks = sdl::get_ticks()
    let sdl_callback = ||: bool {
        let curr_ticks = sdl::get_ticks()
        dtime = (curr_ticks - prev_ticks) as f32 / 1000.0
        prev_ticks = curr_ticks

        let key_states = sdl::get_keyboard_state()
        for it in key_callbacks.iter() {
            if key_states[it.key as u32] != 0 {
                it.value()
            }
        }

        let mx: i32
        let my: i32
        sdl::get_relative_mouse_state(&mx, &my)
        rotate_camera(mx, -my, MOUSE_LOOK_SENSITIVITY)

        image.clear()
        zbuffer.clear()
        for tri in mesh.triangles.iter() {
            project_and_draw(tri.p0, tri.p1, tri.p2, color)
        }

        texture.write_image(image)
        renderer.copy_and_display(texture)

        return true
    }
    sdl::run_main_loop(sdl_callback)
}