import std::image::{ Image, Color, draw }
import std::vec::{ Vec2i, Vec2f, Vec3f }
import std::fs
import std::sv::SV
import std::matrix::Matrix4f
import std::sdl
import std::argparse

import @zbuffer::{ ZBuffer}

let size_f: Vec2f
let image: &Image
let zbuffer: &ZBuffer
let light_dir: Vec3f
let aspect_ratio: Vec2f
let backface_culling: bool

let camera_transform: Matrix4f
let camera_pos: Vec3f
let camera_dir: Vec3f
let camera_up: Vec3f

def vec_to_col(vec: Vec3f, scale: f32 = 1.0): Color {
    vec = (vec.normalized() * 128.0 + 128.0) * scale
    return Color(vec.x as u8, vec.y as u8, vec.z as u8)
}

def draw_triangle_camera_space(
    p0: Vec3f,
    p1: Vec3f,
    p2: Vec3f,
    c0: Color,
    c1: Color,
    c2: Color
) {
    let cam_normal = (p1 - p0).cross(p2 - p0).normalized()
    // // backface culling
    if backface_culling and cam_normal.dot(-1.0 * p0) < 0.0 {
        return
    }

    // project to screen space
    let p0_s = Vec2f(p0.x / p0.z, p0.y / p0.z)
    let p1_s = Vec2f(p1.x / p1.z, p1.y / p1.z)
    let p2_s = Vec2f(p2.x / p2.z, p2.y / p2.z)

    // project to image space (and flip y axis)
    let p0_i = (Vec2f(p0_s.x, -p0_s.y) / aspect_ratio + 1.0) * 0.5 * size_f
    let p1_i = (Vec2f(p1_s.x, -p1_s.y) / aspect_ratio + 1.0) * 0.5 * size_f
    let p2_i = (Vec2f(p2_s.x, -p2_s.y) / aspect_ratio + 1.0) * 0.5 * size_f

    fill_triangle_zc(
        p0_i.to_i32(),
        p1_i.to_i32(),
        p2_i.to_i32(),
        p0.z,
        p1.z,
        p2.z,
        c0: c0,
        c1: c1,
        c2: c2,
    )
}

def interp_color(c0: Color, c1: Color, t: f32): Color {
    return Color(
        (c0.r as f32 * (1.0 - t) + c1.r as f32 * t) as u8,
        (c0.g as f32 * (1.0 - t) + c1.g as f32 * t) as u8,
        (c0.b as f32 * (1.0 - t) + c1.b as f32 * t) as u8,
    )
}

def interp_vec(v0: Vec3f, v1: Vec3f, t: f32): Vec3f {
    return v0 * (1.0 - t) + v1 * t
}

def swap<T>(a: &T, b: &T) {
    let tmp = *a
    *a = *b
    *b = tmp
}

def project_and_draw(tri: Triangle, color: Color) {
    // project to camera space
    let p0 = camera_transform * tri.p0
    let p1 = camera_transform * tri.p1
    let p2 = camera_transform * tri.p2

    let c0 = vec_to_col(tri.n0)
    let c1 = vec_to_col(tri.n1)
    let c2 = vec_to_col(tri.n2)

    let ps: [Vec3f; 3] = [p0, p1, p2]
    let cs: [Color; 3] = [c0, c1, c2]

    let in_tris: [u32; 3]
    let in_idx = 0

    let out_tris: [u32; 3]
    let out_idx = 0

    let MIN_CLIP = 0.2

    if p0.z < MIN_CLIP then out_tris[out_idx++] = 0 else in_tris[in_idx++] = 0
    if p1.z < MIN_CLIP then out_tris[out_idx++] = 1 else in_tris[in_idx++] = 1
    if p2.z < MIN_CLIP then out_tris[out_idx++] = 2 else in_tris[in_idx++] = 2

    match out_idx {
        // Nothing is clipped, draw full triangle
        0 => draw_triangle_camera_space(p0, p1, p2, c0, c1, c2)

        // One vertex is clipped
        1 => {
            // Ensure winding order is correct
            if out_tris[0] == 1 then swap<u32>(&in_tris[0], &in_tris[1])

            let o_p0 = ps[out_tris[0]]
            let o_c0 = cs[out_tris[0]]
            let i_p0 = ps[in_tris[0]]
            let i_p1 = ps[in_tris[1]]
            let i_c0 = cs[in_tris[0]]
            let i_c1 = cs[in_tris[1]]

            let t0 = (MIN_CLIP - o_p0.z) / (i_p0.z - o_p0.z)
            let t1 = (MIN_CLIP - o_p0.z) / (i_p1.z - o_p0.z)

            let n_p0 = interp_vec(o_p0, i_p0, t0)
            let n_c0 = interp_color(i_c0, o_c0, t0)
            let n_p1 = interp_vec(o_p0, i_p1, t1)
            let n_c1 = interp_color(i_c1, o_c0, t1)

            draw_triangle_camera_space(i_p0, i_p1, n_p0, i_c0, i_c1, n_c0)
            draw_triangle_camera_space(i_p1, n_p1, n_p0, i_c1, n_c1, n_c0)
        }

        // Two vertices are clipped
        2 => {
            // Ensure winding order is correct
            if in_tris[0] == 1 then swap<u32>(&out_tris[0], &out_tris[1])

            let o_p0 = ps[out_tris[0]]
            let o_c0 = cs[out_tris[0]]
            let o_p1 = ps[out_tris[1]]
            let o_c1 = cs[out_tris[1]]
            let i_p0 = ps[in_tris[0]]
            let i_c0 = cs[in_tris[0]]

            let t0 = (MIN_CLIP - o_p0.z) / (i_p0.z - o_p0.z)
            let t1 = (MIN_CLIP - o_p1.z) / (i_p0.z - o_p1.z)

            let n_p0 = interp_vec(o_p0, i_p0, t0)
            let n_c0 = interp_color(i_c0, o_c0, t0)
            let n_p1 = interp_vec(o_p1, i_p0, t1)
            let n_c1 = interp_color(i_c0, o_c1, t1)

            draw_triangle_camera_space(i_p0, n_p0, n_p1, i_c0, n_c0, n_c1)
        }

        // All vertices are clipped, do nothing
        3 => {}
        else => assert false, `Unreachable: in_idx={in_idx}, out_idx={out_idx}`
    }
}


def draw_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    draw::line(image, p0.x, p0.y, p1.x, p1.y, color)
    draw::line(image, p1.x, p1.y, p2.x, p2.y, color)
    draw::line(image, p2.x, p2.y, p0.x, p0.y, color)
}


def i32::sign(this): i32 => (this > 0) as i32 - (this < 0) as i32
def is_ok(a: i32, b: i32): bool => a.sign() == b.sign() or a == 0

//! Fill a triangle, while interpolating depth and color for the vertices
[flatten]
def fill_triangle_zc(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    c0: Color,
    c1: Color,
    c2: Color,
) {
    let min_x = p0.x.min(p1.x.min(p2.x)).max(0)
    let min_y = p0.y.min(p1.y.min(p2.y)).max(0)
    let max_x = p0.x.max(p1.x.max(p2.x)).min((image.width - 1) as i32)
    let max_y = p0.y.max(p1.y.max(p2.y)).min((image.height - 1) as i32)

    let denom = (p0.x - p2.x)*(p1.y - p2.y) - (p1.x - p2.x)*(p0.y - p2.y)

    for let x = min_x; x <= max_x; x += 1 {
        for let y = min_y; y <= max_y; y += 1 {
            let u  = (p1.y - p2.y)*(x - p2.x) + (p2.x - p1.x)*(y - p2.y)
            let v  = (p2.y - p0.y)*(x - p2.x) + (p0.x - p2.x)*(y - p2.y)
            let w = denom - u - v

            if is_ok(u, denom) and is_ok(v, denom) and is_ok(w, denom) {
                let z = (z0 * u as f32 + z1 * v as f32 + z2 * w as f32) / denom as f32
                let col = Color(
                    ((c0.r as i32 * u + c1.r as i32 * v + c2.r as i32 * w) / denom) as u8,
                    ((c0.g as i32 * u + c1.g as i32 * v + c2.g as i32 * w) / denom) as u8,
                    ((c0.b as i32 * u + c1.b as i32 * v + c2.b as i32 * w) / denom) as u8,
                )

                if zbuffer.put_if_closer(x as u32, y as u32, z) {
                    image.set(x as u32, y as u32, col)
                }
            }
        }
    }
}

struct Triangle {
    p0, p1, p2 : Vec3f
    n0, n1, n2 : Vec3f
}


struct Mesh {
    triangles: $[Triangle]
}

struct Vertex {
    pos: Vec3f
    tex: Vec2f
    nor: Vec3f
}


def Mesh::from_obj(filename: str): Mesh {
    let file = fs::read_file(filename)
    defer file.free()

    let sv = file.sv()
    let vectors: $[Vec3f] = $[]
    defer vectors.free()

    let normals: $[Vec3f] = $[]
    defer normals.free()

    let textures: $[Vec2f] = $[]
    defer textures.free()

    let parse_vertex = |line: &SV|: Vertex {
        let part = line.chop_by_delim(' ')
        let pos = vectors[part.chop_u32() - 1]
        part.chop_left(1)
        let texcoord = textures[part.chop_u32() - 1]
        part.chop_left(1)
        let normal = normals[part.chop_u32() - 1]
        line.trim()
        return Vertex(pos, texcoord, normal)
    }

    let triangles: $[Triangle] = $[]
    for line in sv.lines() {
        match line.chop_word() {
            "v" => vectors.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()))
            "vn" => normals.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()))
            "vt" => textures.push(Vec2f(line.chop_f32(), line.chop_f32()))
            "f" => {
                let p0 = parse_vertex(&line)
                let p1 = parse_vertex(&line)

                while line.len > 0 {
                    let p2 = parse_vertex(&line)
                    triangles += Triangle(p0.pos, p1.pos, p2.pos, p0.nor, p1.nor, p2.nor)
                    p1 = p2
                }
            }
            else => {}
        }
    }
    let mesh = Mesh(triangles)

    return mesh
}

def update_camera(origin: &Vec3f, direction: &Vec3f) {
    let up = Vec3f(0.0, 1.0, 0.0)
    *direction = direction.normalized()
    let z = *direction
    let x = up.cross(z).normalized()
    let y = z.cross(x).normalized()

    camera_transform = Matrix4f::make(
        x.x, x.y, x.z, -origin.dot(x),
        y.x, y.y, y.z, -origin.dot(y),
        z.x, z.y, z.z, -origin.dot(z),
        0.0, 0.0, 0.0, 1.0
    )
}

def rotate_vector(v: Vec3f, axis: Vec3f, angle: f32): Vec3f {
    let cos_theta = angle.cos()
    let sin_theta = angle.sin()

    // v_rot = v*cos(theta) + (axis x v)*sin(theta) + axis*(axis . v)*(1-cos(theta))
    let term1 = v * cos_theta
    let term2 = axis.cross(v) * sin_theta
    let dot_av = axis.dot(v)
    let term3 = axis * dot_av * (1.0 - cos_theta)

    return term1 + term2 + term3
}

def run_ui(mesh: &Mesh) {
    let width = image.width
    let height = image.height

    // SDL code follows
    sdl::init(sdl::INIT_EVERYTHING)
    sdl::set_relative_mouse_mode(true)

    let window: &sdl::Window
    let renderer: &sdl::Renderer
    sdl::create_window_renderer(1280, 720, 0, &window, &renderer)
    let texture = renderer.create_texture(
        sdl::PIXELFORMAT_ABGR8888,
        sdl::TEXTUREACCESS_STREAMING,
        width as i32,
        height as i32,
    )

    let MOVE_SENSITIVITY: f32 = 5.0
    let KEYBOARD_LOOK_SENSITIVITY: f32 = 1.5
    let MOUSE_LOOK_SENSITIVITY: f32 = 0.2
    let dtime: f32 = 0.0

    let rotate_camera = |dx: i32, dy: i32, sensitivity: f32| {
        if dx == 0 and dy == 0 return
        let yaw_rad = dx as f32 * sensitivity * dtime
        let pitch_rad = dy as f32 * sensitivity * dtime

        camera_dir = rotate_vector(camera_dir, camera_up, yaw_rad)
        let right = camera_dir.cross(camera_up).normalized()
        let new_dir_after_pitch = rotate_vector(camera_dir, right, pitch_rad)

        if new_dir_after_pitch.dot(camera_up).abs() < 0.995 {
            camera_dir = new_dir_after_pitch
        }
        update_camera(&camera_pos, &camera_dir)
    }

    // TODO: Only move along X-Z plane with WASD, and not along the Y axis
    // TODO: This is only for keys that are _held down_, and we can't handle just keydowns
    //       here (for eg: jumping is a one-time thing when space is first pressed)
    let key_callbacks: ${sdl::Key: @fn()} = ${
        W: || {
            camera_pos = camera_pos + camera_dir * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        S: || {
            camera_pos = camera_pos - camera_dir * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        A: || {
            let delta = camera_dir.cross(Vec3f(0.0, 1.0, 0.0)).normalized() * dtime * MOVE_SENSITIVITY
            camera_pos = camera_pos + delta
            update_camera(&camera_pos, &camera_dir)
        },
        D: || {
            let delta = camera_dir.cross(Vec3f(0.0, 1.0, 0.0)).normalized() * dtime * MOVE_SENSITIVITY
            camera_pos = camera_pos - delta
            update_camera(&camera_pos, &camera_dir)
        },
        Z: || {
            camera_pos = camera_pos + camera_up * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        X: || {
            camera_pos = camera_pos - camera_up * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },

        Up:    || => rotate_camera(0, 1, KEYBOARD_LOOK_SENSITIVITY),
        Down:  || => rotate_camera(0, -1, KEYBOARD_LOOK_SENSITIVITY),
        Left:  || => rotate_camera(-1, 0, KEYBOARD_LOOK_SENSITIVITY),
        Right: || => rotate_camera(1, 0, KEYBOARD_LOOK_SENSITIVITY),
    }

    let fps_sum = 0i
    let fps_window_size = 10

    let frame = 0
    let prev_ticks = sdl::get_ticks()

    let dummy_color = Color(255, 0, 0)

    let sdl_callback = ||: bool {
        let curr_ticks = sdl::get_ticks()
        dtime = (curr_ticks - prev_ticks) as f32 / 1000.0
        prev_ticks = curr_ticks

        let key_states = sdl::get_keyboard_state()
        for it in key_callbacks.iter() {
            if key_states[it.key as u32] != 0 {
                it.value()
            }
        }

        let mx: i32
        let my: i32
        sdl::get_relative_mouse_state(&mx, &my)
        rotate_camera(mx, -my, MOUSE_LOOK_SENSITIVITY)

        image.clear()
        zbuffer.clear()
        for tri in mesh.triangles.iter() {
            project_and_draw(tri, dummy_color)
        }

        texture.write_image(image)
        renderer.copy_and_display(texture)

        let fps = (1.0 / dtime) as i32
        fps_sum += fps

        if frame % fps_window_size == 0 {
            let fps_avg = fps_sum / fps_window_size as i32
            window.set_title(`FPS: {fps_avg}`)
            fps_sum = 0
        }

        ++frame
        return true
    }
    sdl::run_main_loop(sdl_callback)
}

def main(argc: i32, argv: &str) {
    let parser = argparse::Parser::make("render3d")
    let model = parser.add_str("-o", help: "Path to the .obj file", defolt: "./assets/dragon.obj")
    let res = parser.add_str("-r", help: "Render resolution", defolt: "960x540")
    let opt_bf_cull = parser.add_bool("-b", help: "Backface culling", action: StoreFalse)
    parser.parse(argc, argv)

    let res_sv = SV::from_str(*res)
    let width = res_sv.chop_u32()
    let height = if {
        res_sv.is_empty() => width
        else => {
            res_sv.chop_left(1)
            yield res_sv.chop_u32()
        }
    }

    backface_culling = *opt_bf_cull

    aspect_ratio = Vec2f(width as f32 / height as f32, 1.0)
    size_f = Vec2f(width as f32, height as f32)
    image = Image::new(width, height)
    zbuffer = ZBuffer::new(width, height)

    light_dir = Vec3f(1.0, -1.0, 0.0).normalized()

    camera_pos = Vec3f(0.0, 0.0, -4.0)
    camera_dir = Vec3f(0.0, 0.0, 1.0)
    camera_up = Vec3f(0.0, 1.0, 0.0)
    update_camera(&camera_pos, &camera_dir)

    let color = Color(255, 0, 0)
    let mesh = Mesh::from_obj(*model)

    run_ui(&mesh)
}