import std::image::{ Image, Color, draw }
import std::vec::{ Vec2i, Vec2f, Vec3f }
import std::fs
import std::matrix::Matrix4f

import @zbuffer::{ ZBuffer}

let size_f: Vec2f
let image: &Image
let zbuffer: &ZBuffer
let camera_transform: Matrix4f
let light_dir: Vec3f

def project_and_draw(p0: Vec3f, p1: Vec3f, p2: Vec3f, color: Color) {

    // project to camera space
    let p0_c = camera_transform * p0
    let p1_c = camera_transform * p1
    let p2_c = camera_transform * p2

    // project to screen space
    let p0_s = Vec2f(p0_c.x / p0_c.z, p0_c.y / p0_c.z)
    let p1_s = Vec2f(p1_c.x / p1_c.z, p1_c.y / p1_c.z)
    let p2_s = Vec2f(p2_c.x / p2_c.z, p2_c.y / p2_c.z)

    // project to image space (and flip y axis)
    let p0_i = (Vec2f(p0_s.x, -p0_s.y) + 1.0) * 0.5 * size_f
    let p1_i = (Vec2f(p1_s.x, -p1_s.y) + 1.0) * 0.5 * size_f
    let p2_i = (Vec2f(p2_s.x, -p2_s.y) + 1.0) * 0.5 * size_f

    // TEMP: color based on normal
    let normal = (p1 - p0).cross(p2 - p0).normalized()
    let scale = normal.dot(-1.0 * light_dir).max(0.1)

    normal = normal * 128.0 + 128.0
    normal = normal * scale

    let c = Color(normal.x as u8, normal.y as u8, normal.z as u8)
    // let c = Color(scale as u8, scale as u8, scale as u8)

    fill_triangle(
        p0_i.to_i32(),
        p1_i.to_i32(),
        p2_i.to_i32(),
        p0.z,
        p1.z,
        p2.z,
        c
    )
}


def draw_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    draw::line(image, p0.x, p0.y, p1.x, p1.y, color)
    draw::line(image, p1.x, p1.y, p2.x, p2.y, color)
    draw::line(image, p2.x, p2.y, p0.x, p0.y, color)
}


def fill_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    let min_x = p0.x.min(p1.x.min(p2.x)).max(0)
    let min_y = p0.y.min(p1.y.min(p2.y)).max(0)
    let max_x = p0.x.max(p1.x.max(p2.x)).min((image.width - 1) as i32)
    let max_y = p0.y.max(p1.y.max(p2.y)).min((image.height - 1) as i32)

    let denom = (p0.x - p2.x)*(p1.y - p2.y) - (p1.x - p2.x)*(p0.y - p2.y)

    for let x = min_x; x <= max_x; x += 1 {
        for let y = min_y; y <= max_y; y += 1 {
            let u  = (p1.y - p2.y)*(x - p2.x) + (p2.x - p1.x)*(y - p2.y)
            let v  = (p2.y - p0.y)*(x - p2.x) + (p0.x - p2.x)*(y - p2.y)
            let w = denom - u - v

            if u >= 0 and v >= 0 and w >= 0 {
                let z = (z0 * u as f32 + z1 * v as f32 + z2 * w as f32) / denom as f32
                if zbuffer.put_if_closer(x as u32, y as u32, z) {
                    image.set(x as u32, y as u32, color)
                }
            }
        }
    }
}

struct Triangle {
    p0, p1, p2 : Vec3f
}


struct Mesh {
    triangles: $[Triangle]
}


def Mesh::from_obj(filename: str, offset: Vec3f): Mesh {
    let file = fs::read_file(filename)
    defer file.free()

    let sv = file.sv()
    let vectors: $[Vec3f] = $[]
    defer vectors.free()

    let normals: $[Vec3f] = $[]
    defer normals.free()

    let textures: $[Vec2f] = $[]
    defer textures.free()

    let triangles: $[Triangle] = $[]
    for line in sv.lines() {
        match line.chop_word() {
            "v" => vectors.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()) + offset)
            "vn" => normals.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()))
            "vt" => textures.push(Vec2f(line.chop_f32(), line.chop_f32()))
            "f" => {
                let s0 = line.chop_by_delim(' ')
                let v0 = vectors[s0.chop_u32() - 1]
                s0.chop_left(1)
                let t0 = textures[s0.chop_u32() - 1]
                s0.chop_left(1)
                let n0 = normals[s0.chop_u32() - 1]

                let s1 = line.chop_by_delim(' ')
                let v1 = vectors[s1.chop_u32() - 1]
                s1.chop_left(1)
                let t1 = textures[s1.chop_u32() - 1]
                s1.chop_left(1)
                let n1 = normals[s1.chop_u32() - 1]

                let s2 = line.chop_by_delim(' ')
                let v2 = vectors[s2.chop_u32() - 1]
                s2.chop_left(1)
                let t2 = textures[s2.chop_u32() - 1]
                s2.chop_left(1)
                let n2 = normals[s2.chop_u32() - 1]

                triangles += Triangle(v0, v1, v2)  //  n0, n1, n2, t0, t1, t2
            }
            else => {}
        }
    }
    let mesh = Mesh(triangles)

    return mesh
}

def update_camera(origin: &Vec3f, direction: &Vec3f) {
    let up = Vec3f(0.0, 1.0, 0.0)
    *direction = direction.normalized()
    let z = *direction
    let x = up.cross(z).normalized()
    let y = z.cross(x).normalized()

    camera_transform = Matrix4f::make(
        x.x, x.y, x.z, -origin.dot(x),
        y.x, y.y, y.z, -origin.dot(y),
        z.x, z.y, z.z, -origin.dot(z),
        0.0, 0.0, 0.0, 1.0
    )
}

def main() {
    let width = 720
    let height = 720
    size_f = Vec2f(width as f32, height as f32)
    image = Image::new(width, height)
    zbuffer = ZBuffer::new(width, height)

    light_dir = Vec3f(1.0, -1.0, 0.0).normalized()

    let camera_pos = Vec3f(-4.0, 0.0, 2.0)
    let camera_dir = Vec3f(1.0, 0.0, 1.0)
    update_camera(&camera_pos, &camera_dir)

    let color = Color(255, 0, 0)
    let mesh = Mesh::from_obj("assets/dragon.obj", Vec3f(0.0, -2.0, 5.0))

    image.clear()
    zbuffer.clear()
    for tri in mesh.triangles.iter() {
        project_and_draw(tri.p0, tri.p1, tri.p2, color)
    }
    image.save("triangle.png")
}