import std::image::{ Image, Color, draw }
import std::vec::{ Vec2i, Vec2f, Vec3f }
import std::fs
import std::sv::SV
import std::matrix::Matrix4f
import std::og
import std::argparse
import std::math

import @zbuffer::{ ZBuffer}
import @bvh::{ BVH }
import @bounds::{ Bounds }
import @ray::{ Ray }

let size_f: Vec2f
let image: &Image
let zbuffer: &ZBuffer
let light_dir: Vec3f
let aspect_ratio: Vec2f
let backface_culling: bool

let camera_transform: Matrix4f
let camera_pos: Vec3f
let camera_dir: Vec3f
let camera_up: Vec3f

let focal_length: f32 = 1.0

def vec_to_col(vec: Vec3f, scale: f32 = 1.0): Color {
    vec = (vec.normalized() * 128.0 + 128.0) * scale
    return Color(vec.x as u8, vec.y as u8, vec.z as u8)
}

def camera_to_screen(p0: Vec3f): Vec2i {
    // project to screen space
    let p0_s = Vec2f(p0.x / p0.z, p0.y / p0.z) * focal_length

    // project to image space (and flip y axis)
    let p0_i = (Vec2f(p0_s.x, -p0_s.y) / aspect_ratio + 1.0) * 0.5 * size_f
    return p0_i.to_i32()
}

def world_to_screen(p0: Vec3f): Vec2i => camera_to_screen(camera_transform * p0)

def draw_triangle_camera_space(
    p0: Vec3f,
    p1: Vec3f,
    p2: Vec3f,
    c0: Color,
    c1: Color,
    c2: Color
) {
    let cam_normal = (p1 - p0).cross(p2 - p0).normalized()
    // // backface culling
    if backface_culling and cam_normal.dot(-1.0 * p0) < 0.0 {
        return
    }

    fill_triangle_zc(
        camera_to_screen(p0),
        camera_to_screen(p1),
        camera_to_screen(p2),
        p0.z,
        p1.z,
        p2.z,
        c0: c0,
        c1: c1,
        c2: c2,
    )
}

def interp_color(c0: Color, c1: Color, t: f32): Color {
    return Color(
        (c0.r as f32 * (1.0 - t) + c1.r as f32 * t) as u8,
        (c0.g as f32 * (1.0 - t) + c1.g as f32 * t) as u8,
        (c0.b as f32 * (1.0 - t) + c1.b as f32 * t) as u8,
    )
}

def interp_vec(v0: Vec3f, v1: Vec3f, t: f32): Vec3f {
    return v0 * (1.0 - t) + v1 * t
}

def swap<T>(a: &T, b: &T) {
    let tmp = *a
    *a = *b
    *b = tmp
}

let MIN_CLIP: f32 = 0.2

def draw_triangle_clipped(tri: Triangle) {
    // project to camera space
    let p0 = camera_transform * tri.p0
    let p1 = camera_transform * tri.p1
    let p2 = camera_transform * tri.p2

    let c0 = vec_to_col(tri.n0)
    let c1 = vec_to_col(tri.n1)
    let c2 = vec_to_col(tri.n2)

    let ps: [Vec3f; 3] = [p0, p1, p2]
    let cs: [Color; 3] = [c0, c1, c2]

    let in_tris: [u32; 3]
    let in_idx = 0

    let out_tris: [u32; 3]
    let out_idx = 0


    if p0.z < MIN_CLIP then out_tris[out_idx++] = 0 else in_tris[in_idx++] = 0
    if p1.z < MIN_CLIP then out_tris[out_idx++] = 1 else in_tris[in_idx++] = 1
    if p2.z < MIN_CLIP then out_tris[out_idx++] = 2 else in_tris[in_idx++] = 2

    match out_idx {
        // Nothing is clipped, draw full triangle
        0 => draw_triangle_camera_space(p0, p1, p2, c0, c1, c2)

        // One vertex is clipped
        1 => {
            // Ensure winding order is correct
            if out_tris[0] == 1 then swap<u32>(&in_tris[0], &in_tris[1])

            let o_p0 = ps[out_tris[0]]
            let o_c0 = cs[out_tris[0]]
            let i_p0 = ps[in_tris[0]]
            let i_p1 = ps[in_tris[1]]
            let i_c0 = cs[in_tris[0]]
            let i_c1 = cs[in_tris[1]]

            let t0 = (MIN_CLIP - o_p0.z) / (i_p0.z - o_p0.z)
            let t1 = (MIN_CLIP - o_p0.z) / (i_p1.z - o_p0.z)

            let n_p0 = interp_vec(o_p0, i_p0, t0)
            let n_c0 = interp_color(i_c0, o_c0, t0)
            let n_p1 = interp_vec(o_p0, i_p1, t1)
            let n_c1 = interp_color(i_c1, o_c0, t1)

            draw_triangle_camera_space(i_p0, i_p1, n_p0, i_c0, i_c1, n_c0)
            draw_triangle_camera_space(i_p1, n_p1, n_p0, i_c1, n_c1, n_c0)
        }

        // Two vertices are clipped
        2 => {
            // Ensure winding order is correct
            if in_tris[0] == 1 then swap<u32>(&out_tris[0], &out_tris[1])

            let o_p0 = ps[out_tris[0]]
            let o_c0 = cs[out_tris[0]]
            let o_p1 = ps[out_tris[1]]
            let o_c1 = cs[out_tris[1]]
            let i_p0 = ps[in_tris[0]]
            let i_c0 = cs[in_tris[0]]

            let t0 = (MIN_CLIP - o_p0.z) / (i_p0.z - o_p0.z)
            let t1 = (MIN_CLIP - o_p1.z) / (i_p0.z - o_p1.z)

            let n_p0 = interp_vec(o_p0, i_p0, t0)
            let n_c0 = interp_color(i_c0, o_c0, t0)
            let n_p1 = interp_vec(o_p1, i_p0, t1)
            let n_c1 = interp_color(i_c0, o_c1, t1)

            draw_triangle_camera_space(i_p0, n_p0, n_p1, i_c0, n_c0, n_c1)
        }

        // All vertices are clipped, do nothing
        3 => {}
        else => assert false, `Unreachable: in_idx={in_idx}, out_idx={out_idx}`
    }
}


def draw_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    draw::line(image, p0.x, p0.y, p1.x, p1.y, color)
    draw::line(image, p1.x, p1.y, p2.x, p2.y, color)
    draw::line(image, p2.x, p2.y, p0.x, p0.y, color)
}


def i32::sign(this): i32 => (this > 0) as i32 - (this < 0) as i32
def is_ok(a: i32, b: i32): bool => a.sign() == b.sign() or a == 0

//! Fill a triangle, while interpolating depth and color for the vertices
[flatten]
def fill_triangle_zc(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    c0: Color,
    c1: Color,
    c2: Color,
) {
    let min_x = p0.x.min(p1.x.min(p2.x)).max(0)
    let min_y = p0.y.min(p1.y.min(p2.y)).max(0)
    let max_x = p0.x.max(p1.x.max(p2.x)).min((image.width - 1) as i32)
    let max_y = p0.y.max(p1.y.max(p2.y)).min((image.height - 1) as i32)

    let denom = (p0.x - p2.x)*(p1.y - p2.y) - (p1.x - p2.x)*(p0.y - p2.y)

    for let x = min_x; x <= max_x; x += 1 {
        for let y = min_y; y <= max_y; y += 1 {
            let u  = (p1.y - p2.y)*(x - p2.x) + (p2.x - p1.x)*(y - p2.y)
            let v  = (p2.y - p0.y)*(x - p2.x) + (p0.x - p2.x)*(y - p2.y)
            let w = denom - u - v

            if is_ok(u, denom) and is_ok(v, denom) and is_ok(w, denom) {
                let z = (z0 * u as f32 + z1 * v as f32 + z2 * w as f32) / denom as f32
                let col = Color(
                    ((c0.r as i32 * u + c1.r as i32 * v + c2.r as i32 * w) / denom) as u8,
                    ((c0.g as i32 * u + c1.g as i32 * v + c2.g as i32 * w) / denom) as u8,
                    ((c0.b as i32 * u + c1.b as i32 * v + c2.b as i32 * w) / denom) as u8,
                )

                if zbuffer.put_if_closer(x as u32, y as u32, z) {
                    image.set(x as u32, y as u32, col)
                }
            }
        }
    }
}

struct Triangle {
    p0, p1, p2 : Vec3f
    n0, n1, n2 : Vec3f
}

def Triangle::bounds(this): Bounds => Bounds(
    Vec3f(
        .p0.x.min(.p1.x).min(.p2.x),
        .p0.y.min(.p1.y).min(.p2.y),
        .p0.z.min(.p1.z).min(.p2.z)
    ),
    Vec3f(
        .p0.x.max(.p1.x).max(.p2.x),
        .p0.y.max(.p1.y).max(.p2.y),
        .p0.z.max(.p1.z).max(.p2.z)
    )
)

struct Mesh {
    triangles: $[Triangle]
}

struct Vertex {
    pos: Vec3f
    tex: Vec2f
    nor: Vec3f
}


def Mesh::from_obj(filename: str): Mesh {
    let file = fs::read_file(filename)
    defer file.free()

    let sv = file.sv()
    let vectors: $[Vec3f] = $[]
    defer vectors.free()

    let normals: $[Vec3f] = $[]
    defer normals.free()

    let textures: $[Vec2f] = $[]
    defer textures.free()

    let parse_vertex = |line: &SV|: Vertex {
        let part = line.chop_by_delim(' ')
        let pos = vectors[part.chop_u32() - 1]
        part.chop_left(1)
        let texcoord = textures[part.chop_u32() - 1]
        part.chop_left(1)
        let normal = normals[part.chop_u32() - 1]
        line.trim()
        return Vertex(pos, texcoord, normal)
    }

    let triangles: $[Triangle] = $[]
    for line in sv.lines() {
        match line.chop_word() {
            "v" => vectors.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()))
            "vn" => normals.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()))
            "vt" => textures.push(Vec2f(line.chop_f32(), line.chop_f32()))
            "f" => {
                let p0 = parse_vertex(&line)
                let p1 = parse_vertex(&line)

                while line.len > 0 {
                    let p2 = parse_vertex(&line)
                    triangles += Triangle(p0.pos, p1.pos, p2.pos, p0.nor, p1.nor, p2.nor)
                    p1 = p2
                }
            }
            else => {}
        }
    }
    let mesh = Mesh(triangles)

    return mesh
}

def update_camera(origin: &Vec3f, direction: &Vec3f) {
    let up = Vec3f(0.0, 1.0, 0.0)
    *direction = direction.normalized()
    let z = *direction
    let x = up.cross(z).normalized()
    let y = z.cross(x).normalized()

    camera_transform = Matrix4f::make(
        x.x, x.y, x.z, -origin.dot(x),
        y.x, y.y, y.z, -origin.dot(y),
        z.x, z.y, z.z, -origin.dot(z),
        0.0, 0.0, 0.0, 1.0
    )
}

def rotate_vector(v: Vec3f, axis: Vec3f, angle: f32): Vec3f {
    let cos_theta = angle.cos()
    let sin_theta = angle.sin()

    // v_rot = v*cos(theta) + (axis x v)*sin(theta) + axis*(axis . v)*(1-cos(theta))
    let term1 = v * cos_theta
    let term2 = axis.cross(v) * sin_theta
    let dot_av = axis.dot(v)
    let term3 = axis * dot_av * (1.0 - cos_theta)

    return term1 + term2 + term3
}

def run_ui(mesh: &Mesh) {
    let width = image.width
    let height = image.height

    // SDL code follows
    og::init(width, height, "Render")
    og::grab_input(true)
    og::show_cursor(false)

    let MOVE_SENSITIVITY: f32 = 5.0
    let KEYBOARD_LOOK_SENSITIVITY: f32 = 1.5
    let MOUSE_LOOK_SENSITIVITY: f32 = 0.2
    let dtime: f32 = 0.0

    let rotate_camera = |dx: i32, dy: i32, sensitivity: f32| {
        if dx == 0 and dy == 0 return
        let yaw_rad = dx as f32 * sensitivity * dtime
        let pitch_rad = dy as f32 * sensitivity * dtime

        camera_dir = rotate_vector(camera_dir, camera_up, yaw_rad)
        let right = camera_dir.cross(camera_up).normalized()
        let new_dir_after_pitch = rotate_vector(camera_dir, right, pitch_rad)

        if new_dir_after_pitch.dot(camera_up).abs() < 0.995 {
            camera_dir = new_dir_after_pitch
        }
        update_camera(&camera_pos, &camera_dir)
    }

    // TODO: Only move along X-Z plane with WASD, and not along the Y axis
    // TODO: This is only for keys that are _held down_, and we can't handle just keydowns
    //       here (for eg: jumping is a one-time thing when space is first pressed)
    let key_callbacks: ${og::Key: @fn()} = ${
        W: || {
            camera_pos = camera_pos + camera_dir * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        S: || {
            camera_pos = camera_pos - camera_dir * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        A: || {
            let delta = camera_dir.cross(Vec3f(0.0, 1.0, 0.0)).normalized() * dtime * MOVE_SENSITIVITY
            camera_pos = camera_pos + delta
            update_camera(&camera_pos, &camera_dir)
        },
        D: || {
            let delta = camera_dir.cross(Vec3f(0.0, 1.0, 0.0)).normalized() * dtime * MOVE_SENSITIVITY
            camera_pos = camera_pos - delta
            update_camera(&camera_pos, &camera_dir)
        },
        Z: || {
            camera_pos = camera_pos + camera_up * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        X: || {
            camera_pos = camera_pos - camera_up * dtime * MOVE_SENSITIVITY
            update_camera(&camera_pos, &camera_dir)
        },
        M: || => focal_length *= 1.1,
        N: || => focal_length /= 1.1,

        Up:    || => rotate_camera(0, 1, KEYBOARD_LOOK_SENSITIVITY),
        Down:  || => rotate_camera(0, -1, KEYBOARD_LOOK_SENSITIVITY),
        Left:  || => rotate_camera(-1, 0, KEYBOARD_LOOK_SENSITIVITY),
        Right: || => rotate_camera(1, 0, KEYBOARD_LOOK_SENSITIVITY),
        Escape: || {
            og::quit()
            std::exit(0)
        }
    }

    let prev_ticks = og::get_ticks()
    while og::is_running() {
        let curr_ticks = og::get_ticks()
        dtime = (curr_ticks - prev_ticks) as f32 / 1000.0
        prev_ticks = curr_ticks

        for it in key_callbacks.iter() {
            if og::is_key_down(it.key) {
                it.value()
            }
        }

        if og::is_key_pressed(F) {
            og::toggle_fullscreen()
        }

        if og::is_key_pressed(O) and depth_limit > 0 then depth_limit--
        if og::is_key_pressed(P) then depth_limit++
        if og::is_key_pressed(J) then show_mesh = not show_mesh
        if og::is_key_pressed(H) then show_ray_and_hit = not show_ray_and_hit
        if og::is_key_pressed(G) {
            ray = Ray(camera_pos, camera_dir)
            hit_nodes.clear()
            bvh.hit(&ray, hit_nodes)
        }

        let mouse = og::get_mouse_delta()
        rotate_camera(mouse.x, -mouse.y, MOUSE_LOOK_SENSITIVITY)

        image.clear()
        zbuffer.clear()
        if show_mesh {
            for tri in mesh.triangles.iter() {
                draw_triangle_clipped(tri)
            }
        }
        draw_bvh(bvh)

        if show_ray_and_hit {
            draw_ray()
            draw_hit_nodes()
        }

        og::display_image(image)
    }
}

let bvh: &BVH<Triangle> = null
let hit_nodes: $[&BVH<Triangle>] = null
let ray: Ray
let show_mesh: bool = true
let show_ray_and_hit: bool = false

def draw_line_clipped_thick(
    p0_w: Vec3f,
    p1_w: Vec3f,
    color: Color,
    thickness: f32
) {
    // The idea is to codegen triangles for a cylinder and draw those
    let RAD_PARTS = 3
    let LENGTH_PARTS = u32::max(10, (p1_w - p0_w).length() as u32)

    let dir = p1_w - p0_w
    let axis = dir.normalized()

    let simple_tri = |p0: Vec3f, p1: Vec3f, p2: Vec3f| {
        let norm = (p1 - p0).cross(p2 - p0).normalized()
        draw_triangle_clipped(Triangle(p0, p1, p2, norm, norm, norm))
    }

    let dir_delta = dir / LENGTH_PARTS as f32
    let base = axis.cross(Vec3f(1.0, 1.0, 0.0)).normalized() * thickness

    for let i = 0; i < RAD_PARTS; i += 1 {
        let s0 = base.rotate_axis(axis, (i + 0) as f32 / RAD_PARTS as f32 * math::PI * 2.0)
        let s1 = base.rotate_axis(axis, (i + 1) as f32 / RAD_PARTS as f32 * math::PI * 2.0)

        for let j = 0; j < LENGTH_PARTS; j += 1 {
            let t0 = dir_delta * ((j + 0) as f32)
            let t1 = dir_delta * ((j + 1) as f32)

            let v00 = p0_w + s0 + t0
            let v01 = p0_w + s0 + t1
            let v10 = p0_w + s1 + t0
            let v11 = p0_w + s1 + t1

            simple_tri(v00, v10, v11)
            simple_tri(v00, v11, v01)
        }
    }
    // std::exit(1)
}

def draw_line_clipped(
    p0_w: Vec3f,
    p1_w: Vec3f,
    color: Color,
    ignore_z: bool = false
) {
    let p0_c = camera_transform * p0_w
    let p1_c = camera_transform * p1_w

    let count = (p0_c.z < MIN_CLIP) as i32 + (p1_c.z < MIN_CLIP) as i32
    match count {
        0 => {
            // Nothing clipped. Draw line...
            let p0 = camera_to_screen(p0_c)
            let p1 = camera_to_screen(p1_c)
            draw_line_z(p0, p1, p0_c.z, p1_c.z, color, ignore_z)
        }

        1 => {
            // Ensure p0 is always the one that needs to be clipped
            if p1_c.z < p0_c.z {
                let tmp = p1_c; p1_c = p0_c; p0_c = tmp;
            }

            let t = (MIN_CLIP - p0_c.z) / (p1_c.z - p0_c.z)
            let n0 = interp_vec(p0_c, p1_c, t)

            let p0 = camera_to_screen(p1_c)
            let p1 = camera_to_screen(n0)
            draw_line_z(p0, p1, p1_c.z, n0.z, color, ignore_z)
        }

        2 => {
            // Both points clipped. Do not draw anything.
        }
        else => assert false, "unreachable"

    }

}

def draw_line_z(
    p1: Vec2i,
    p2: Vec2i,
    z1: f32,
    z2: f32,
    color: Color,
    ignore_z: bool = false
) {
    let x1 = p1.x as f32
    let y1 = p1.y as f32
    let x2 = p2.x as f32
    let y2 = p2.y as f32

    // line algorithm
    let dx = x2 - x1
    let dy = y2 - y1
    let dz = z2 - z1

    let xt: f32
    let yt: f32
    let zt: f32

    if dx.abs() >= dy.abs() {
        if x2 < x1 {
            xt = x1; x1 = x2; x2 = xt
            yt = y1; y1 = y2; y2 = yt
            zt = z1; z1 = z2; z2 = zt
        }

        let y = y1
        let z = z1
        let y_inc = (y2 - y1) / (x2 - x1)
        let z_inc = (z2 - z1) / (x2 - x1)

        for let x = x1; x <= x2; x += 1.0 {
            if 0 <= x as u32 < image.width and 0 <= y as u32 < image.height {
                if ignore_z or zbuffer.put_if_closer(x as u32, y as u32, z) {
                    image.set(x as u32, y as u32, color)
                }
            }

            y += y_inc
            z += z_inc
        }

    } else {
        if y2 < y1 {
            xt = x1; x1 = x2; x2 = xt
            yt = y1; y1 = y2; y2 = yt
            zt = z1; z1 = z2; z2 = zt
        }

        let x = x1
        let z = z1
        let x_inc = (x2 - x1) / (y2 - y1)
        let z_inc = (z2 - z1) / (y2 - y1)

        for let y = y1; y <= y2; y += 1.0 {
            if 0 <= x as u32 < image.width and 0 <= y as u32 < image.height {
                if ignore_z or zbuffer.put_if_closer(x as u32, y as u32, z) {
                    image.set(x as u32, y as u32, color)
                }
            }

            x += x_inc
            z += z_inc
        }
    }
}

def draw_bounds_projected(bounds: Bounds, color: Color, thick: bool = false) {
    let min = bounds.min;
    let max = bounds.max;

    let C = [
        Vec3f(min.x, min.y, min.z),
        Vec3f(max.x, min.y, min.z),
        Vec3f(max.x, max.y, min.z),
        Vec3f(min.x, max.y, min.z),
        Vec3f(min.x, min.y, max.z),
        Vec3f(max.x, min.y, max.z),
        Vec3f(max.x, max.y, max.z),
        Vec3f(min.x, max.y, max.z),
    ]

    let thickness = 0.01
    let do_draw = |p0: Vec3f, p1: Vec3f| {
        if thick {
            draw_line_clipped_thick(p0, p1, color, thickness)
        } else {
            draw_line_clipped(p0, p1, color)
        }
    }
    do_draw(C[0], C[1])
    do_draw(C[1], C[2])
    do_draw(C[2], C[3])
    do_draw(C[3], C[0])
    do_draw(C[4], C[5])
    do_draw(C[5], C[6])
    do_draw(C[6], C[7])
    do_draw(C[7], C[4])
    do_draw(C[0], C[4])
    do_draw(C[1], C[5])
    do_draw(C[2], C[6])
    do_draw(C[3], C[7])
}

let depth_limit: u32 = 0
def draw_bvh(root: &BVH<Triangle>, depth: u32 = 0) {
    if depth > depth_limit - 1 {
        return
    }

    // Draw the current node's bounds
    if depth == depth_limit - 1 {
        draw_bounds_projected(root.bounds, Color(0, 255, 0))
    }

    if not root.is_leaf {
        draw_bvh(root.l, depth + 1)
        draw_bvh(root.r, depth + 1)
    }
}

def draw_ray() {
    let ray_length = 20.0
    let start = ray.pos
    let end = ray.at(ray_length)
    draw_line_clipped_thick(start, end, Color(0, 0, 255), 0.02)
}

def draw_hit_nodes() {
    for node in hit_nodes.iter() {
        draw_bounds_projected(node.bounds, Color(255, 0, 0), thick: true)
    }
}

def main(argc: i32, argv: &str) {
    let parser = argparse::Parser::make("render3d")
    let model = parser.add_str("-o", help: "Path to the .obj file", defolt: "./assets/dragon.obj")
    let res = parser.add_str("-r", help: "Render resolution", defolt: "960x540")
    let opt_bf_cull = parser.add_bool("-b", help: "Backface culling", action: StoreFalse)
    parser.parse(argc, argv)

    let res_sv = SV::from_str(*res)
    let width = res_sv.chop_u32()
    let height = if {
        res_sv.is_empty() => width
        else => {
            res_sv.chop_left(1)
            yield res_sv.chop_u32()
        }
    }

    backface_culling = *opt_bf_cull

    aspect_ratio = Vec2f(width as f32 / height as f32, 1.0)
    size_f = Vec2f(width as f32, height as f32)
    image = Image::new(width, height)
    zbuffer = ZBuffer::new(width, height)

    light_dir = Vec3f(1.0, -1.0, 0.0).normalized()

    camera_pos = Vec3f(0.0, 2.0, -4.0)
    camera_dir = Vec3f(0.0, 0.0, 1.0)
    camera_up = Vec3f(0.0, 1.0, 0.0)
    update_camera(&camera_pos, &camera_dir)

    let color = Color(255, 0, 0)
    let mesh = Mesh::from_obj(*model)

    bvh = BVH<Triangle>::create(mesh.triangles)
    hit_nodes = $[]

    ray = Ray(
        pos: Vec3f(0.0, 2.0, -4.0),
        dir: Vec3f(0.0, 0.0, 1.0)
    )

    bvh.hit(&ray, hit_nodes)

    run_ui(&mesh)
}