import std::image::{ Image, Color, draw }
import std::vec::{ Vec2i, Vec2f, Vec3f }
import std::fs

import @zbuffer::{ ZBuffer}

let size_f: Vec2f
let image: &Image
let zbuffer: &ZBuffer

def project_and_draw(p0: Vec3f, p1: Vec3f, p2: Vec3f, color: Color) {
    let light_dir = Vec3f(-1.0, -1.0, 0.0).normalized()

    // project to camera space
    let p0_c = Vec2f(p0.x / p0.z, p0.y / p0.z)
    let p1_c = Vec2f(p1.x / p1.z, p1.y / p1.z)
    let p2_c = Vec2f(p2.x / p2.z, p2.y / p2.z)

    // project to screen space
    let p0_s = ((p0_c + 1.0) * size_f) / 2.0
    let p1_s = ((p1_c + 1.0) * size_f) / 2.0
    let p2_s = ((p2_c + 1.0) * size_f) / 2.0

    // flip y axis
    p0_s.y = size_f.y - 1.0 - p0_s.y
    p1_s.y = size_f.y - 1.0 - p1_s.y
    p2_s.y = size_f.y - 1.0 - p2_s.y

    // TEMP: color based on normal
    let normal = (p1 - p0).cross(p2 - p0).normalized()
    let scale = normal.dot(-1.0 * light_dir).max(0.1)

    normal = normal * 128.0 + 128.0
    normal = normal * scale

    let c = Color(normal.x as u8, normal.y as u8, normal.z as u8)
    // let c = Color(scale as u8, scale as u8, scale as u8)

    fill_triangle(
        p0_s.to_i32(),
        p1_s.to_i32(),
        p2_s.to_i32(),
        p0.z,
        p1.z,
        p2.z,
        c
    )
}


def draw_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    draw::line(image, p0.x, p0.y, p1.x, p1.y, color)
    draw::line(image, p1.x, p1.y, p2.x, p2.y, color)
    draw::line(image, p2.x, p2.y, p0.x, p0.y, color)
}


def fill_triangle(
    p0: Vec2i,
    p1: Vec2i,
    p2: Vec2i,
    z0: f32,
    z1: f32,
    z2: f32,
    color: Color
) {
    let min_x = p0.x.min(p1.x.min(p2.x)).max(0)
    let min_y = p0.y.min(p1.y.min(p2.y)).max(0)
    let max_x = p0.x.max(p1.x.max(p2.x)).min((image.width - 1) as i32)
    let max_y = p0.y.max(p1.y.max(p2.y)).min((image.height - 1) as i32)

    let denom = (p0.x - p2.x)*(p1.y - p2.y) - (p1.x - p2.x)*(p0.y - p2.y)

    for let x = min_x; x <= max_x; x += 1 {
        for let y = min_y; y <= max_y; y += 1 {
            let u  = (p1.y - p2.y)*(x - p2.x) + (p2.x - p1.x)*(y - p2.y)
            let v  = (p2.y - p0.y)*(x - p2.x) + (p0.x - p2.x)*(y - p2.y)
            let w = denom - u - v

            if u >= 0 and v >= 0 and w >= 0 {
                let z = (z0 * u as f32 + z1 * v as f32 + z2 * w as f32) / denom as f32
                if zbuffer.put_if_closer(x as u32, y as u32, z) {
                    image.set(x as u32, y as u32, color)
                }
            }
        }
    }
}

struct Triangle {
    p0, p1, p2 : Vec3f
}


struct Mesh {
    triangles: $[Triangle]
}


def Mesh::from_obj(filename: str, offset: Vec3f): Mesh {
    let file = fs::read_file(filename)
    defer file.free()

    let sv = file.sv()
    let vectors: $[Vec3f] = $[]
    defer vectors.free()

    let normals: $[Vec3f] = $[]
    defer normals.free()

    let textures: $[Vec2f] = $[]
    defer textures.free()

    let triangles: $[Triangle] = $[]
    for line in sv.lines() {
        match line.chop_word() {
            "v" => vectors.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()) + offset)
            "vn" => normals.push(Vec3f(line.chop_f32(), line.chop_f32(), line.chop_f32()))
            "vt" => textures.push(Vec2f(line.chop_f32(), line.chop_f32()))
            "f" => {
                let s0 = line.chop_by_delim(' ')
                let v0 = vectors[s0.chop_u32() - 1]
                s0.chop_left(1)
                let t0 = textures[s0.chop_u32() - 1]
                s0.chop_left(1)
                let n0 = normals[s0.chop_u32() - 1]

                let s1 = line.chop_by_delim(' ')
                let v1 = vectors[s1.chop_u32() - 1]
                s1.chop_left(1)
                let t1 = textures[s1.chop_u32() - 1]
                s1.chop_left(1)
                let n1 = normals[s1.chop_u32() - 1]

                let s2 = line.chop_by_delim(' ')
                let v2 = vectors[s2.chop_u32() - 1]
                s2.chop_left(1)
                let t2 = textures[s2.chop_u32() - 1]
                s2.chop_left(1)
                let n2 = normals[s2.chop_u32() - 1]

                triangles += Triangle(v0, v1, v2)  //  n0, n1, n2, t0, t1, t2
            }
            else => {}
        }
    }
    let mesh = Mesh(triangles)

    return mesh
}


def main() {
    let width = 720*4
    let height = 720*4
    size_f = Vec2f(width as f32, height as f32)
    image = Image::new(width, height)
    zbuffer = ZBuffer::new(width, height)


    let p0 = Vec3f(-1.0, -1.0, 4.0)
    let p1 = Vec3f(1.0, 3.0, 4.0)
    let p2 = Vec3f(2.0, -1.0, 10.0)
    let color = Color(255, 0, 0)
    let mesh = Mesh::from_obj("assets/dragon.obj", Vec3f(0.0, -2.0, 5.0))

    image.clear()
    zbuffer.clear()
    for tri in mesh.triangles.iter() {
        project_and_draw(tri.p0, tri.p1, tri.p2, color)
    }
    image.save("triangle.png")
}